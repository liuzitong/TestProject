#ifndef QXPACK_IC_ALGOR_ARYPEAKFTR_HPP
#define QXPACK_IC_ALGOR_ARYPEAKFTR_HPP

#include "qxpack_ic_algor_ary.hpp"
#include "qxpack_ic_algor_peak.hpp"

#include <cstring>
#include <cstdint>
#include <type_traits>
#include <utility>
#include <cmath>
#include <cstdio>
#include <cstdlib>

#ifndef QXPACK_IC_CXX11
#if __cplusplus >= 201103L || ( defined(_MSC_VER) && _MSC_VER >= 1800 )
#  define QXPACK_IC_CXX11
#else
#  error "this template require C++11 !"
#endif
#endif

// ////////////////////////////////////////////////////////////////////////////
// : API List
// ----------------------------------------------------------------------------
// peakEvlopFtrAry_Lerp -- make peak envelope, use linear interpolation method
//  
// ----------------------------------------------------------------------------
// ////////////////////////////////////////////////////////////////////////////

namespace QxPack {
namespace IcAlgor {



//! \details this filter make the peak envelope of spec. array ( use linear interpolation )
//! \param  ary        [in_out]  the array point
//! \param  ary_sz     [in]  the array size
//! \param  pk_ary     [in]  the peak position generated by IcAlgor::findNextPeak().middle
//! \param  pk_sz      [in]  the peak array size
//! \param  dist_thr   [in]  the peak dist threshold
template <typename T>
auto     peakEvlopFtrAry_Lerp ( T *ary, size_t ary_sz, const size_t *pkm, size_t pkm_sz, size_t dist_thr ) -> std::pair<size_t,bool>
{
    using RslType = std::pair<size_t,bool>;

    if ( ary_sz < 1 || ary == nullptr ) { return RslType(0,false); }
    if ( pkm == nullptr || pkm_sz < 2   ) { return RslType(0,false); }

    // make sure has just two peaks
    if ( pkm[0] > ary_sz || pkm[ pkm_sz - 1 ] > ary_sz ) { return RslType(0,false); }

    // process middle peaks
    auto ret = true; auto solve_num = size_t(0);
    auto pk_prev = pkm[0]; auto pk_curr = pkm[0]; T val[2]; size_t diff = 0;
    for ( size_t i = 1; i < pkm_sz; i ++ ) {
        pk_curr = pkm[i];
        if ( pk_curr >= ary_sz ) { ret = false; break; }
        diff = pk_curr - pk_prev + 1;
        if ( diff <= dist_thr ) {
            val[0] = ary[ pk_prev ]; val[1] = ary[ pk_curr ];
            IcAlgor::linearInterpolAry( val, 2, &ary[ pk_prev ], diff );
            ++ solve_num;
        }
        pk_prev = pk_curr;
    }

    return RslType( solve_num, ret );
}



}
}
#endif
